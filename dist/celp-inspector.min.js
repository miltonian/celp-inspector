(function() {
    // === Configuration ===
    const INSPECTOR_ID = 'minimal-react-inspector';
    const HIGHLIGHT_COLOR = '#00a8ff';
    const MESSAGE_PREFIX = 'REACT_INSPECTOR';
    
    // === State ===
    let isInspecting = false;
    let selectedElement = null;
    let debugMode = true; // Enable debugging
    
    // === Debugging ===
    function debug(...args) {
      if (debugMode) console.log('[React Inspector]', ...args);
    }
    
    // === DOM Elements ===
    // Create container
    const container = document.createElement('div');
    container.id = INSPECTOR_ID;
    container.style.position = 'fixed';
    container.style.pointerEvents = 'none';
    container.style.zIndex = '999999';
    document.body.appendChild(container);
    
    // Create highlighter element
    const highlighter = document.createElement('div');
    highlighter.style.position = 'fixed';
    highlighter.style.border = `2px solid ${HIGHLIGHT_COLOR}`;
    highlighter.style.backgroundColor = `${HIGHLIGHT_COLOR}20`;
    highlighter.style.pointerEvents = 'none';
    highlighter.style.zIndex = '99999';
    highlighter.style.display = 'none';
    container.appendChild(highlighter);
    
    // Create overlay for preventing interactions
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.zIndex = '99998';
    overlay.style.backgroundColor = 'transparent';
    overlay.style.display = 'none';
    overlay.style.cursor = 'crosshair';
    document.body.appendChild(overlay);
    
    // Create tooltip for component info
    const tooltip = document.createElement('div');
    tooltip.style.position = 'fixed';
    tooltip.style.backgroundColor = '#333';
    tooltip.style.color = 'white';
    tooltip.style.padding = '4px 8px';
    tooltip.style.borderRadius = '4px';
    tooltip.style.fontSize = '12px';
    tooltip.style.zIndex = '100000';
    tooltip.style.display = 'none';
    container.appendChild(tooltip);
    
    // === Utility Functions ===
    // Get React fiber node from DOM element
    function getFiberNodeFromDOM(element) {
      if (!element) return null;
      
      try {
        // Try different known React internal property patterns
        const fiberKey = Object.keys(element).find(
          key => key.startsWith('__reactFiber$') || 
                key.startsWith('__reactInternalInstance$')
        );
        
        const propsKey = Object.keys(element).find(
          key => key.startsWith('__reactProps$')
        );
        
        if (fiberKey) {
          debug('Found React fiber via', fiberKey);
          return element[fiberKey];
        } else if (propsKey) {
          debug('Found React props, but no fiber');
        } else {
          debug('No React properties found on element');
        }
        
        return null;
      } catch (err) {
        debug('Error getting fiber node:', err);
        return null;
      }
    }
    
    // Get component name
    function getComponentName(fiber) {
      if (!fiber) return 'Unknown';
      try {
        const { type } = fiber;
        if (!type) return 'Unknown';
        
        return type.displayName || type.name || (typeof type === 'string' ? type : 'Anonymous');
      } catch (err) {
        debug('Error getting component name:', err);
        return 'Unknown';
      }
    }
    
    // Get component props
    function getComponentProps(fiber) {
      if (!fiber) return {};
      try {
        return fiber.memoizedProps || {};
      } catch (err) {
        debug('Error getting props:', err);
        return {};
      }
    }
    
    // Update highlighter position
    function updateHighlight(element) {
      if (!element) {
        highlighter.style.display = 'none';
        return;
      }
      
      const rect = element.getBoundingClientRect();
      debug('Highlighting rect:', rect);
      
      highlighter.style.left = `${rect.left + window.scrollX}px`;
      highlighter.style.top = `${rect.top + window.scrollY}px`;
      highlighter.style.width = `${rect.width}px`;
      highlighter.style.height = `${rect.height}px`;
      highlighter.style.display = 'block';
    }
    
    // Update tooltip
    function updateTooltip(element, x, y) {
      if (!element) {
        tooltip.style.display = 'none';
        return;
      }
      
      const fiber = getFiberNodeFromDOM(element);
      if (!fiber) {
        // Show element tag if no React component found
        tooltip.textContent = element.tagName.toLowerCase();
      } else {
        tooltip.textContent = getComponentName(fiber);
      }
      
      tooltip.style.left = `${x + 10}px`;
      tooltip.style.top = `${y + 10}px`;
      tooltip.style.display = 'block';
    }
    
    // === Core Functionality ===
    // Toggle inspection mode
    function toggleInspection(enabled) {
      if (enabled === undefined) {
        isInspecting = !isInspecting;
      } else {
        isInspecting = !!enabled;
      }
      
      debug('Inspection mode:', isInspecting);
      
      // Update UI
      overlay.style.display = isInspecting ? 'block' : 'none';
      if (!isInspecting) {
        highlighter.style.display = 'none';
        tooltip.style.display = 'none';
      }
      
      // Send message about state change
      sendMessage({
        type: 'INSPECTION_STATE_CHANGED',
        isInspecting
      });
    }
    
    function selectElement(element) {
        if (!element) return;
        debug('Selecting element:', element);
        
        const fiber = getFiberNodeFromDOM(element);
        const componentName = fiber ? getComponentName(fiber) : element.tagName.toLowerCase();
        
        // Send message about selection - using the format from ComponentInspector.tsx
        window.parent.postMessage({
          type: 'ELEMENT_SELECTED',
          element: {
            tagName: element.tagName.toLowerCase(),
            reactName: componentName,
            id: element.id || '',
            className: element.className || '',
            dataset: JSON.stringify(element.dataset || {}),
          }
        }, '*');
        
        // Also keep your existing message for backwards compatibility
        sendMessage({
          type: 'ELEMENT_SELECTED',
          data: {
            componentName: componentName,
            props: fiber ? getComponentProps(fiber) : null
          }
        });
        
        debug('Selected:', componentName);
      }
    
    // === Messaging ===
    // Send a message
    function sendMessage(data) {
      window.postMessage({
        source: MESSAGE_PREFIX,
        ...data
      }, '*');
    }
    
    // Receive messages
    window.addEventListener('message', function(event) {
      const data = event.data;
      
      // Ignore messages from other sources
      if (!data || typeof data !== 'object' || !data.type) return;
      
      // Handle specific message types
      if (data.type === 'TOGGLE_COMPONENT_SELECTION') {
        debug('Received toggle message:', data);
        toggleInspection(data.enabled);
      }
    });
    
    // === Event Handlers ===
    // Handle mouse movement for inspection
    function handleMouseMove(e) {
    if (!isInspecting) return;
  
    // Temporarily hide the overlay so that elementFromPoint returns the underlying element
    overlay.style.display = 'none';
    const element = document.elementFromPoint(e.clientX, e.clientY);
    overlay.style.display = 'block';
  
    // Ignore the overlay, highlighter, or container elements
    if (!element || element === overlay || element === highlighter || container.contains(element)) {
      return;
    }
    
    debug('Hovering element:', element.tagName, element);
    updateHighlight(element);
    updateTooltip(element, e.clientX, e.clientY);
  }
    
    // Handle click for selection
    function handleClick(e) {
      if (!isInspecting) return;
      
      const element = document.elementFromPoint(e.clientX, e.clientY);
      if (!element || element === overlay || element === highlighter || 
          container.contains(element)) {
        return;
      }
      
      selectElement(element);
      e.preventDefault();
      e.stopPropagation();
    }
    
    overlay.addEventListener('mousemove', handleMouseMove);
    overlay.addEventListener('click', handleClick);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Option+Shift+I (Mac) / Alt+Shift+I (Windows)
      if (e.altKey && e.shiftKey && e.key === 'I') {
        toggleInspection();
      }
      
      // Escape to exit inspect mode
      if (e.key === 'Escape' && isInspecting) {
        toggleInspection(false);
      }
      
      // Debug info with D
      if (e.altKey && e.shiftKey && e.key === 'D') {
        debugMode = !debugMode;
        debug('Debug mode:', debugMode);
      }
    });
    
    // === Public API ===
    window.ReactInspector = {
      toggleInspection,
      isInspecting: () => isInspecting,
      getSelectedElement: () => selectedElement,
      debug: (enabled) => { debugMode = enabled; }
    };
    
    debug('React Component Inspector loaded. Press Option+Shift+I to toggle inspection.');
  })();